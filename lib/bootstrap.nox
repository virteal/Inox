~| bootstrap.nox
 |   Inox standard library.
 |
 | JHR, 2023/01/11, made from test/smoke.nox
 |
 |~


~~ Some basic vocabulary, primitive
to debugger            inox-debugger
to debug               inox-debug
to debug-off           inox-debug-off
to breakpoint          inox-breakpoint
to call-with-it        inox-call-with-it
to without-control     inox-without-control
to without-data        inox-without-data
to with-it             inox-with-it
to without-it          inox-without-it
to it                  inox-it
to with                inox-with  ~~ ToDo: use possibly faster /inox-with
to with-parameters     inox-with-parameters
to without-parameters  inox-without-parameters
to call                inox-call
to if                  inox-if
to ?call               inox-if-call
to call-by-name        inox-call-by-name
to call-by-tag         inox-call-by-tag
to break               inox-break
to inline              inox-inline
to while               inox-while-1 inox-while-2 inox-while-3. inline
to until               inox-while-1 inox-while-2 inox-until-3. inline
to sentinel            inox-sentinel
to jump                inox-jump
to loop                inox-loop
to make-object         inox-make-object
to call                inox-call
to if-else             inox-if-else
to rename              inox-rename
to log                 inox-log
to cast                inox-cast
to loop-while          inox-loop-while. inline
to loop-until          inox-loop-until. inline
to join-text           inox-join-text  ~| A B -- AB |~
to alias               inox-alias
to clear-data          inox-clear-data
to clear-control       inox-clear-control
to make-constant       inox-make-constant
to tag                 inox-tag
to class               inox-class
to type                inox-type
to name                inox-name
to value               inox-value
to definition          inox-definition
to make-global         inox-make-global
to make-control        inox-make-control
to control             inox-control
to upper               inox-upper-control
to upper!              inox-set-upper-control
to data                inox-data
to upper-data          inox-upper-data
to upper-data!         inox-set-upper-data
to immediate!          inox-immediate
to ascii-character     inox-ascii-character
to ascii-code          inox-ascii-code
to inox-dialect        inox-inox-dialect
to forth-dialect       inox-forth-dialect
to current-dialect     inox-current-dialect
to dialect             inox-dialect
to object-set          inox-object-set  ~~ ToDo: @.!
to object-get          inox-object-get  ~~ ToDo: @.
to void?               inox-is-a-void
to boolean?            inox-is-a-boolean
to tag?                inox-is-a-tag
to integer?            inox-is-an-integer
to pointer?            inox-is-a-pointer
to proxy?              inox-is-a-proxy
to verb?               inox-is-a-verb
to text?               inox-is-a-text
to make-actor          inox-make-actor
to actor               inox-actor
to switch-actor        inox-switch-actor
to Ah                  inox-actor
to Ah!                 inox-switch-actor
to IP                  inox-IP
to IP!                 inox-set-IP
to CSP                 inox-CSP
to CSP!                inox-set-CSP
to TOS                 inox-TOS
to TOS!                inox-set-TOS
to to-control          inox-to-control
to from-control        inox-from-control

to ToDo                "ToDo: " swap join-text inox-out
to toDo                ToDo  ~~ Literate mode friendly, it becomes ToDo

~~ Some synonyms, shorter than the original name
to without             without-control
to clear               clear-data

to basic-out           inox-out
to out                 /basic-out call-by-tag  ~~ late binding

~~ Some more, using keyword syntax for ease
to do             call.          inline
to if:then:       ?call.         inline
to if:then:else:  if-else call.  inline
to if:do:         if:then:.      inline
to unless:do:     not? if:do:.   inline
to while:do:      while.         inline
to until:do:      until.         inline
to loop:while:    loop-while.    inline
to do:while:      loop-while.    inline
to loop:until:    loop-until.    inline
to do:until:      loop-until.    inline

to no-debug      debug-off.

to clear-stacks  clear-data clear-control

to missing-verb     "missing-verb "     over join-text out clear-stacks
to missing-method   "missing-method "   over join-text out clear-stacks
to missing-operator "missing-operator " over join-text out clear-stacks

to FATAL-hook    "FATAL" out debugger clear-stacks.
to FATAL         /FATAL-hook call-by-tag.  ~~ late binding

to assert{  call ? not? { "ERROR. Assertion" breakpoint out FATAL } if.

to constant:is:  make-constant.
to global:is:    make-global.
to local:is:     swap rename to-control.

to init-globals
  constant: /inox-version is: "v0.3.1";
  constant: /inox-version-time is: 1674589501315  ;
  constant: "void"        is: cast( 0, 0 );
  constant: /true         is: cast( true:1,    1 );
  constant: /false        is: cast( false:0,   1 );
  constant: /on           is: cast( on:1,      1 );
  constant: /off          is: cast( off:0,     1 );
  constant: /yes          is: cast( yes:1,     1 );
  constant: /no           is: cast( no:0,      1 );
  constant: /failure      is: cast( failure:0, 1 );
  constant: /success      is: cast( success:1, 1 );
  debug debugger
  global:   /safe         is: "safe";
init-globals

to check-globals
  assert{ ( safe =? "safe" ) }
check-globals

~~ ToDo: :xx? special form?
to :success? name /success =?.
to :failure? name /failure =?.
to :on?      name /on      =?.
to :off?     name /off     =?.
to :yes?     name /yes     =?.
to :no?      name /no      =?.

~~ Some basic text manipulations
to prefix  over join-text       ~| A B -- A BA |~
to suffix  over swap join-text  ~| A B -- A AB |~
~~ text-length
~~ text-splice
~~ text-but
~~ text-first
~~ text-last
~~ text-but-last
~~ text-starts-with?
~~ text-ends-with?
~~ text-contains?
~~ text-replace
~~ text-replace-all
~~ text-replace-first
~~ text-replace-last
~~ text-trim
~~ text-trim-left
~~ text-trim-right
~~ text-split-by
~~ text-join-by
~~ text-join join-text
~~ text-split-lines
~~ text-join-lines
~~ text-join-pieces
~~ text-split-pieces
~~ text-split-words
~~ text-join-words
~~ text-split-characters
~~ text-join-characters


~~ Class hierarchy

to thing.super-class      void
to thing.class          /thing

to value.super-class         /thing
to value.class              /value

to void.super-class            /value
to void.class                 /void

to boolean.super-class         /value
to boolean.class              /boolean

to tag.super-class             /value
to tag.class                  /tag

to number.super-class          /value
to number.class               /number

to integer.super-class           /number
to integer.class                /integer

to float.super-class             /value
to float.class                  /float

to object.super-class        /thing
to object.class             /object

to native.super-class            /object
to native.class                 /native

to proxy.super-class             /object
to proxy.class                  /proxy

to block.super-class             /object
to block.class                  /block

to verb.super-class              /object
to verb.class                   /verb


to dump  ~| any -- any |~  ~~ Debug dump of top of stack. TOS is preserved.
  dup, dup    ~~ any  any    any
  class       ~~ any  any   _class
  swap, dup   ~~ any _class  any   any
  type        ~~ any _class  any  _type
  swap, dup   ~~ any _class _type  any   any
  name        ~~ any _class _type  any  _name
  swap, dup   ~~ any _class _type _name  any    any
  value       ~~ any _class _type _name  any   _value
  swap        ~~ any _class _type _name _value  any
  out(
      "class: "  & _class
    & " type: "  & _type
    & " name: "  & _name
    & " value: " & _value
  )
  5 drops

to dump-object  ~| any -- any |~
  dump
  ToDo: "dump each member";


to method  ~| target a-block -- |~  call-with-it without-it ~~ ToDo: one verb


to test ~| name |~
~~ Helper to test verbs. It runs the test-xxx testing verb.
  "Testing " prefix out
  /test-sentinel, over
  "test-" swap join-text, call-by-name
  ~~ checks that stack is unchanged, ie sentinel is still at the top
  /test-sentinel <>? { out( "Stack mismatch!" ) debugger } ?call
  "End of test " prefix out
  drop

to debug-test  ~~ Helper for tests that needs to be debugged
  "Testing " prefix out
  "test-" swap join-text, debug, call-by-name, no-debug
  ~~ ToDo: developer must also check that data stack is unchanged
  "End of debug-test for " prefix out
  drop


~~ verbs with formal parameters are functions called with arguments
to with      /inox-with  ~~ ToDo: inox-with primitive that pushes void:/with


to fn{       safe! with-parameters safe call without-parameters. inline
to function  safe! with-parameters safe call without-parameters. inline


to times:do:
  times:do/sentinel
  >blk >nn ~~ begin
  if: nn> >0? then: {
    while: {
      ( nn> - 1 ) dup >nn! >=0?
    } do: {
      blk> call
    };
  };
  times:do/jump

to times:loop: times:do:.


to decrement 1 -
to increment 1 +


to with-ii       0 >ii. inline
to without-ii    /ii without-control. inline
to with-ii-do    with-ii call without-ii
to ii!           >ii!. inline
to ii            ii>.  inline
to decrement-ii  ii decrement ii!
to increment-ii  ii increment ii!
to --ii          ii decrement dup ii!. ~~ ii> 1 - dup >ii!
to ++ii          ii increment dup ii!
to ii--          ii decrement-ii
to ii++          ii increment-ii
to jj            /ii 1 upper
to jj!           /ii 1 upper!
to kk            /ii 2 upper
to kk!           /ii 2 upper!

to from:to:do:
  #ii-do with
    >ii-block >ii-to >ii-from
    if: ii-from> <=? ii-to> then: {
      do: ii-block> call while: { ii-to> >? ++ii };
    };
  #ii-do without

to from:down-to:do:
  #ii-do with
    >ii-block >ii-down-to >ii
    if: ii-from> >=? ii-down-to> then: {
      do: ii-block> call while: { ii-to> >? --ii };
    };
  #ii-do without

to from:to:by:do:
  #ii-do with
    >ii-block >ii-by >#ii-to >ii
    if: ii-by> >0? then: {
      if: ii-from> <=? ii-to> then: {
        do: ii-block> call while: { ii + ii-by>, ii!, ii <=? ii-to> };
      };
    } else: {
      if: ii-from> >=? ii-to> then: {
        do: ii-block> call while: { ii + ii-by>, ii!, ii >=? ii-to> };
      };
    };
  #ii-do without


~~ ToDo: closures, partial, complete, shared
~~ to closure inox-copy-closure.
~~ to stack-closure inox-copy-stack-closure.


~~ ToDo: array builder using a sentinel in the data stack
~~ to #[     with.
~~ to    ]#  inox-make-with-array

to try-call  ToDo( "Implement inox-try-call" )

to try:
  inox-try/sentinel
    try-call
  inox-try/jump

to try:catch:
  >inox-try:catch
  try-call
  inox-try:catch/without

to try:catch:finally:
  >inox-try:catch:finally
  >inox-try:catch
  try-call
  inox-try:catch:finally> call
  inox-try:catch/without

  ~~ to FATAL inox-FATAL


to InoxStyle
  inox-dialect
  alias(  "To"           "to"              )
  alias(  "While"        " while: { "      )
  alias(  "Do"           " } do: { "       )
  alias(  "EndWhile"     " } ; "           )
  alias(  "Loop"         " loop: { "       )
  alias(  "Until"        " } until: { "    )
  alias(  "EndLoop"      " } ; "           )
  alias(  "Break"        "break"           )
  alias(  "If"           " if: "           )
  alias(  "Then"         " then: { "       )
  alias(  "Else"         " } else: { "     )
  alias(  "EndIf"        " } ; "           )
  alias(  "Times"        "times:"          )
  alias(  "Begin"        "{"               )
  alias(  "End"          " } ; "           )
InoxStyle

~~ Other ideas to consider
~~ defined?( /verb )  ~~ return true if verb is defined
