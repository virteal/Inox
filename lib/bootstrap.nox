~| bootstrap.nox
 |   Inox standard library.
 |
 | JHR, 2023/01/11, made from test/smoke.nox
 |
 |~


~~ Some basic vocabulary, primitive
to the-void             inox-the-void
to noop                 inox-noop
to debugger             inox-debugger
to debug                inox-debug
to no-debug             inox-no-debug
to breakpoint           inox-breakpoint
to run                  inox-run
to run-by-name          inox-run-by-name
to run-by-tag           inox-run-by-tag
to with                 inox-with  ~~ ToDo: use possibly faster /inox-with
to run-with-parameters  inox-run-with-parameters
to run-with-it          inox-run-with-it
to without-local        inox-without-local
to without-data         inox-without-data
to with-it              inox-with-it
to it                   inox-it
to it!                  inox-it!
to if                   inox-if
to if-not               inox-if-not
to break                inox-break
to inline               inox-inline
to while                inox-while-1 inox-while-2 inox-while-3. inline
to until                inox-while-1 inox-while-2 inox-until-3. inline
to sentinel             inox-sentinel
to jump                 inox-jump
to loop                 inox-loop
to make-object          inox-make-object
to run                  inox-run
to if-else              inox-if-else
to rename               inox-rename
to log                  inox-log
to cast                 inox-cast
to loop-while           inox-loop-while. inline
to loop-until           inox-loop-until. inline
to join-text            inox-join-text  ~| A B -- AB |~
to alias                inox-alias
to clear-data           inox-clear-data
to clear-control        inox-clear-control
to make-constant        inox-make-constant
to tag                  inox-tag
to class                inox-class
to type                 inox-type
to name                 inox-name
to value                inox-value
to definition           inox-definition
to make-global          inox-make-global
to make-local           inox-make-local
to local                inox-local
to upper                inox-upper-local
to upper!               inox-set-upper-local
to data                 inox-data
to upper-data           inox-upper-data
to upper-data!          inox-set-upper-data
to immediate!           inox-immediate
to ascii-character      inox-ascii-character
to ascii-code           inox-ascii-code
to inox-dialect         inox-inox-dialect
to forth-dialect        inox-forth-dialect
to current-dialect      inox-current-dialect
to dialect              inox-dialect
to object-set           inox-object-set  ~~ ToDo: @.!
to object-get           inox-object-get  ~~ ToDo: @.
to a-void?              inox-a-void?
to boolean?             inox-a-boolean?
to tag?                 inox-a-tag?
to integer?             inox-an-integer?
to reference?           inox-a-reference?
to proxy?               inox-a-proxy?
to verb?                inox-a-verb?
to text?                inox-a-text?
to make-actor           inox-make-actor
to actor                inox-actor
to switch-actor         inox-switch-actor
to Ah                   inox-actor
to Ah!                  inox-switch-actor
to IP                   inox-IP
to IP!                  inox-set-IP
to CSP                  inox-CSP
to CSP!                 inox-set-CSP
to TOS                  inox-TOS
to TOS!                 inox-set-TOS
to to-control           inox-to-control
to from-control         inox-from-control
to fetch-control        inox-fetch-control
to now                  inox-now

to ToDo                "ToDo: " swap join-text inox-out
to toDo                ToDo  ~~ Literate mode friendly, it becomes ToDo

~~ Some synonyms, shorter than the original name
to without             without-data
to clear               clear-data

to basic-out           inox-out
to out                 /basic-out run-by-tag  ~~ late binding

~~ Some more, using keyword syntax for ease
to do             run.           inline
to if:then:       if.            inline
to if:then:else:  if-else.       inline
to if:do:         if:then:.      inline
to unless:do:     not? if:do:.   inline
to while:do:      while.         inline
to until:do:      until.         inline
to loop:while:    loop-while.    inline
to do:while:      loop-while.    inline
to loop:until:    loop-until.    inline
to do:until:      loop-until.    inline

to and{           if.            inline
to or{            if-not.        inline
to if{            if.            inline
to then{          if.            inline
to when{          if.            inline
to else{          if-not.        inline
to otherwise{     if-not.        inline
to unless{        if-not.        inline

to {}             noop
to {drop}         /drop definition inox-literal. immediate!
to range?         dup <=? and{ >=? }
to range<?        dup <?  and{ >=? }


to clear-stacks  clear-data clear-control

to missing-verb     "missing-verb "     over join-text out clear-stacks
to missing-method   "missing-method "   over join-text out clear-stacks
to missing-operator "missing-operator " over join-text out clear-stacks

to FATAL-hook    "FATAL" out debugger clear-stacks
to FATAL         /FATAL-hook run-by-tag

to ASSERT-hook   "ASSERT" out debugger clear-stacks
to ASSERT        /ASSERT-hook run-by-tag
to assert{       inox-assert. inline

to constant:is:  make-constant
to global:is:    make-global
to local:is:     swap rename to-control

to init-globals
  constant: /inox-version      is: "v0.3.1";
  constant: /inox-version-time is: 1674589501315  ;
  constant: /true              is: cast( true:1,    1 );
  constant: /false             is: cast( false:0,   1 );
  constant: /on                is: cast( on:1,      1 );
  constant: /off               is: cast( off:0,     1 );
  constant: /yes               is: cast( yes:1,     1 );
  constant: /no                is: cast( no:0,      1 );
  constant: /failure           is: cast( failure:0, 1 );
  constant: /success           is: cast( success:1, 1 );
  global:   /safe              is: "safe";
init-globals


to check-globals
  ~~ the safe global variable is ok to store one value outside any stack
  ~~ HERE is used this way in Forth
  ~~ ToDo: a safe{ } method for access to the safe global variable with
  ~~ the protection of a global mutex guard
  assert{ ( safe =? "safe" ) }
check-globals

~~ ToDo: :xx? special form?
to :success? name /success =?
to :failure? name /failure =?
to :on?      name /on      =?
to :off?     name /off     =?
to :yes?     name /yes     =?
to :no?      name /no      =?

~~ Some basic text manipulations
to prefix  over join-text       ~| A B -- A BA |~
to suffix  over swap join-text  ~| A B -- A AB |~
~~ text-length
~~ text-splice
~~ text-but
~~ text-first
~~ text-last
~~ text-but-last
~~ text-starts-with?
~~ text-ends-with?
~~ text-contains?
~~ text-replace
~~ text-replace-all
~~ text-replace-first
~~ text-replace-last
~~ text-trim
~~ text-trim-left
~~ text-trim-right
~~ text-split-by
~~ text-join-by
~~ text-join join-text
~~ text-split-lines
~~ text-join-lines
~~ text-join-pieces
~~ text-split-pieces
~~ text-split-words
~~ text-join-words
~~ text-split-characters
~~ text-join-characters


~~ Class hierarchy

to thing.super-class      the-void
to thing.class          /thing

to value.super-class         /thing
to value.class              /value

to void.super-class            /value
to void.class                 /void

to boolean.super-class         /value
to boolean.class              /boolean

to tag.super-class             /value
to tag.class                  /tag

to number.super-class          /value
to number.class               /number

to integer.super-class           /number
to integer.class                /integer

to float.super-class             /value
to float.class                  /float

to object.super-class        /thing
to object.class             /object

to native.super-class            /object
to native.class                 /native

to proxy.super-class             /object
to proxy.class                  /proxy

to block.super-class             /object
to block.class                  /block

to verb.super-class              /object
to verb.class                   /verb


to dump  ~| any -- any |~  ~~ Debug dump of top of stack. TOS is preserved.
  dup, dup    ~~ any  any    any
  class       ~~ any  any   _class
  swap, dup   ~~ any _class  any   any
  type        ~~ any _class  any  _type
  swap, dup   ~~ any _class _type  any   any
  name        ~~ any _class _type  any  _name
  swap, dup   ~~ any _class _type _name  any    any
  value       ~~ any _class _type _name  any   _value
  swap        ~~ any _class _type _name _value  any
  out(
      "class: "  & _class
    & " type: "  & _type
    & " name: "  & _name
    & " value: " & _value
  )
  5 drops

to dump-object  ~| any -- any |~
  dump
  ToDo: "dump each member";


to method  ~| target a-block -- |~  run-with-it


to test ~| name |~
~~ Helper to test verbs. It runs the test-xxx testing verb.
  "Testing " prefix out
  /test-sentinel, over
  "test-" swap join-text, run-by-name
  ~~ checks that stack is unchanged, ie sentinel is still at the top
  /test-sentinel <>? { out( "Stack mismatch!" ) debugger } if
  "End of test " prefix out
  drop

to debug-test  ~~ Helper for tests that needs to be debugged
  "Testing " prefix out
  dup
  "test-" swap join-text, debug, run-by-name, no-debug
  ~~ ToDo: developer must also check that data stack is unchanged
  "End of debug-test for " prefix out
  drop


~~ verbs with formal parameters are functions called with arguments
to with      /inox-with  ~~ ToDo: inox-with primitive that pushes void:/with
to fn{       run-with-parameters. inline
to function  run-with-parameters. inline


to decrement  1 -
to increment  1 +
to --         decrement
to ++         increment


to decrement-it!  it -- it!
to increment-it!  it ++ it!
to --it!          it -- dup it!
to ++it!          it ++ dup it!
to it--!          it dup -- it!
to it++!          it dup ++ it!
to it{            inox-run-with-it
to do-with-it     inox-run-with-it


to times:do:
  it{
    it >block it!
    if: it >0? then: {
      while: { it--! >=0? } do: {
        block> run
      };
    };
  }

to times:loop:  times:do:.
to times        swap times:do:.


to it-self       it >self
to self          self>
to this-it       it >this
to this          this>
to that-it       it >that
to that          that>

to ii            it.  inline
to ii!           it!. inline
to jj            /it 1 upper
to jj!           /it 1 upper!
to kk            /it 2 upper
to kk!           /it 2 upper!
to ll            /it 3 upper
to ll!           /it 3 upper!

to from:to:do:
  it{
    it >block >ii-to ii!
    if: ii <=? ii-to> then: {
      do: { block> run } while: { ii-to> >? ++it! };
    };
  }

to from:down-to:do:
  it{
    it >block >ii-down-to ii!
    if: ii >=? ii-down-to> then: {
      do: { block> run } while: { ii-to> >? --it! };
    };
  }

to from:to:by:do:
  it{
    it >block >ii-by >ii-to ii!
    if: ii-by> >0? then: {
      if: ii <=? ii-to> then: {
        do: { block> run } while: { ii + ii-by>, ii!, ii <=? ii-to> };
      };
    } else: {
      if: ii >=? ii-to> then: {
        do: { block> run } while: { ii + ii-by>, ii!, ii >=? ii-to> };
      };
    };
  };


~~ ToDo: closures, partial, complete, shared
~~ to closure inox-copy-closure
~~ to stack-closure inox-copy-stack-closure


~~ ToDo: array builder using a sentinel in the data stack
~~ to #[     with
~~ to    ]#  inox-make-with-array

to try-run  ToDo( "Implement inox-try-run" )

to try:
  inox-try/sentinel
    try-run
  inox-try/jump

to try:catch:
  >inox-try:catch
  try-run
  inox-try:catch/without

to try:catch:finally:
  >inox-try:catch:finally
  >inox-try:catch
  try-run
  inox-try:catch:finally> run
  inox-try:catch/without

to try:finally:
  >inox-try:finally
  try-run
  inox-try:finally> run


to InoxStyle
  ~~ ToDo: some literate-inox dialect
  inox-dialect
  alias(  "To"           "to"               )
  alias(  "While"        " while: { "       )
  alias(  "Do"           " } do: { "        )
  alias(  "EndWhile"     " } ; "            )
  alias(  "Loop"         " loop: { "        )
  alias(  "Until"        " } until: { "     )
  alias(  "EndLoop"      " } ; "            )
  alias(  "Break"        "break"            )
  alias(  "If"           " if: "            )
  alias(  "Then"         " then: { "        )
  alias(  "Else"         " } else: { "      )
  alias(  "EndIf"        " } ; "            )
  alias(  "Times"        "times: "          )
  alias(  "Begin"        "{"                )
  alias(  "End"          "}"                )
  alias(  "Scope"        "0 {"              )
  alias(  "EndScope"     " } do-with-it "   )
InoxStyle

To False  false.
To True   true.


constant: /speed-index-loops is: 10000000;

to speed-index
  assert{ speed-index-loops =? 10000000 }
  ~~ How long for integer addition
  now
    times: speed-index-loops do: { 1 1 + drop };
  now swap -
  ~~ How long for no operation
  now
    times: speed-index-loops do: {  };
  now swap -
  ~~ Delta is how long for addition alone
  -
  dup
  out(
    "" & speed-index-loops
    & " times 1 1 + drop in "
    &  & " ms"
  )

~~ speed-index

~~ forth.nox comes next
