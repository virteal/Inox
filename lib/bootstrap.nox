~| bootstrap.nox
 |   Inox standard library
 |
 | JHR, 2023/01/11, made from test/smoke.nox
 |
 |~

~~ Some basic vocabulary, primitive
to while                while-1 while-2 while-3. inline
to until                while-1 while-2 until-3. inline
to immediate!           immediate

~~ Some synonyms, shorter than the original name
to forget              forget-data
to clear               clear-data

to basic-out           inox-out
to out                 /basic-out run-tag  ~~ late binding

to ToDo                "ToDo: " swap text.join out
to toDo                ToDo  ~~ Literate mode friendly, it becomes ToDo

~~ Some more, using keyword syntax for ease
to do             run.           inline
to if:then:       if.            inline
to if:then:else:  if-else.       inline
to if:do:         if:then:.      inline
to unless:do:     not if:do:.    inline
to while:do:      while.         inline
to until:do:      until.         inline
to loop:while:    loop-while.    inline
to do:while:      loop-while.    inline
to loop:until:    loop-until.    inline
to do:until:      loop-until.    inline

to and{           if.            inline
to or{            if-not.        inline
to then{          if.            inline
to else{          if-not.        inline

to {}             noop
to {drop}         /drop definition literal. immediate!
to range?         dup <= and{ >= }
to range<?        dup <  and{ >= }


to clear-stacks   clear-data clear-control

to missing-verb     "missing-verb "     over text.join out clear-stacks
to missing-method   "missing-method "   over text.join out clear-stacks
to missing-operator "missing-operator " over text.join out clear-stacks

to FATAL-hook    "FATAL" out debugger clear-stacks
to FATAL         /FATAL-hook run-tag

to ASSERT-hook   "ASSERT" out debugger clear-stacks
to ASSERT        /ASSERT-hook run-tag
to assert{       assert. inline

to constant:is:  make-constant
to global:is:    make-global
to local:is:     swap, rename, to-control

to init-globals
  constant: /inox-version      is: "v0.3.1";
  constant: /inox-version-time is: 1674589501; ~~ ToDo: overflow when ms
  constant: /true              is: cast( true:1,    1 );
  constant: /false             is: cast( false:0,   1 );
  constant: /on                is: cast( on:1,      1 );
  constant: /off               is: cast( off:0,     1 );
  constant: /yes               is: cast( yes:1,     1 );
  constant: /no                is: cast( no:0,      1 );
  constant: /failure           is: cast( failure:0, 1 );
  constant: /success           is: cast( success:1, 1 );
  global:   /safe              is: "safe";
init-globals


to check-globals
  ~~ the safe global variable is ok to store one value outside any stack
  ~~ HERE is used this way in Forth
  ~~ ToDo: a safe{ } method for access to the safe global variable with
  ~~ the protection of a global mutex guard
  assert{ ( safe = "safe" ) }
check-globals

~~ ToDo: :xx? special form?
to :success?  name-of /success =
to :failure?  name-of /failure =
to :on?       name-of /on      =
to :off?      name-of /off     =
to :yes?      name-of /yes     =
to :no?       name-of /no      =


~~ Class hierarchy

to thing.super-class      the-void
to thing.class          /thing

to value.super-class         /thing
to value.class              /value

to void.super-class            /value
to void.class                 /void

to boolean.super-class         /value
to boolean.class              /boolean

to tag.super-class             /value
to tag.class                  /tag

to number.super-class          /value
to number.class               /number

to integer.super-class           /number
to integer.class                /integer

to float.super-class             /value
to float.class                  /float

to text.super-class              /value
to text.class                   /text

to object.super-class        /thing
to object.class             /object

to native.super-class            /object
to native.class                 /native

to proxy.super-class             /object
to proxy.class                  /proxy

to block.super-class             /object
to block.class                  /block

to verb.super-class              /object
to verb.class                   /verb


to dump  ~| any -- any |~  ~~ Debug dump of top of stack. TOS is preserved.
  dup, dup    ~~ any  any    any
  class-of    ~~ any  any   _class
  swap, dup   ~~ any _class  any   any
  type-of     ~~ any _class  any  _type
  swap, dup   ~~ any _class _type  any   any
  name-of     ~~ any _class _type  any  _name
  swap, dup   ~~ any _class _type _name  any    any
  value-of    ~~ any _class _type _name  any   _value
  swap        ~~ any _class _type _name _value  any
  out(
      "class: "  & _class
    & " type: "  & _type
    & " name: "  & _name
    & " value: " & _value
  )
  5 drops

to dump-object  ~| any -- any |~
  dump
  ToDo: "dump each member";


to method  ~| target a-block -- |~  run-with-it. inline
to .{      ~| target a-block -- |~  run-with-it. inline
to >{      ~| target a-block -- |~  run-with-it. inline


~~ verbs with formal parameters are functions called with arguments
to with      /with
to function  run-with-parameters. inline
to /{        run-with-parameters. inline


to decrement  1 -
to increment  1 +
to --         decrement
to ++         increment


to decrement-it!  it -- it!
to increment-it!  it ++ it!
to --it!          it -- dup it!
to ++it!          it ++ dup it!
to it--!          it dup -- it!
to it++!          it dup ++ it!
to it{            run-with-it
to do-with-it     run-with-it


to times:do:
  it{
    it >block, it!
    if: it >0 then: {
      while: { it--! >0 } do: {
        block> run
      };
    };
  }

to times:loop:  times:do:.
to times        swap times:do:.


to it-self       it >self
to self          self>
to this-it       it >this
to this          this>
to that-it       it >that
to that          that>

to ii            it.  inline
to ii!           it!. inline
to upper         upper-local
to upper!        set-upper-local
to jj            /it 1 upper
to jj!           /it 1 upper!
to kk            /it 2 upper
to kk!           /it 2 upper!
to ll            /it 3 upper
to ll!           /it 3 upper!

to from:to:do:
  it{
    it >block, >ii-to, ii!
    if: ii <= ii-to> then: {
      do: { block> run } while: { ii-to> > ++it! };
    };
  }

to from:down-to:do:
  it{
    it >block, >ii-down-to, ii!
    if: ii >= ii-down-to> then: {
      do: { block> run } while: { ii-to> > --it! };
    };
  }

to from:to:by:do:
  it{
    it >block, >ii-by, >ii-to, ii!
    if: ii-by> >0 then: {
      if: ii <= ii-to> then: {
        do: { block> run } while: { ii + ii-by>, ii!, ii <= ii-to> };
      };
    } else: {
      if: ii >= ii-to> then: {
        do: { block> run } while: { ii + ii-by>, ii!, ii >= ii-to> };
      };
    };
  };


~~ ToDo: closures, partial, complete, shared
~~ to closure inox-copy-closure
~~ to stack-closure inox-copy-stack-closure


~~ ToDo: array builder using a sentinel in the data stack
~~ to #[     with
~~ to    ]#  inox-make-with-array

to try-run  ToDo( "Implement inox-try-run" )

to try
  inox-try/sentinel
    try-run
  inox-try/long-jump

to try:catch:
  >inox-try:catch
  try
  inox-try:catch/forget

to try:catch:finally:
  >inox-try:catch:finally
  >inox-try:catch
  try
  inox-try:catch:finally> run
  inox-try:catch:finaly/forget

to try:finally:
  >inox-try:finally
  try-run
  inox-try:finally> run
  inox-try:finaly/forget


~~ text class
to text.&             text.join
to prefix             over text.join       ~| A B -- A BA |~
to suffix             over swap text.join  ~| A B -- A AB |~
to text.first         text.cut
to text.last          text.but
to text.last          text.but
~~ text.but-last      text.cut
~~ text.starts-with?
~~ text.ends-with?
~~ text.contains?
~~ text.replace
~~ text.replace-all
~~ text.replace-first
~~ text.replace-last
~~ text.trim
~~ text.trim-left
~~ text.trim-right
~~ text.split-by
~~ text.join-by
~~ text.split-lines
~~ text.join-lines
~~ text.join-pieces
~~ text.split-pieces
~~ text.split-words
~~ text.join-words
~~ text.split-characters
~~ text.join-characters


to test ~| name |~
~~ Helper to test verbs. It runs the test-xxx testing verb.
  "Testing " prefix out
  /test-sentinel, over
  "test-" swap text.join, run-name
  ~~ checks that stack is unchanged, ie sentinel is still at the top
  /test-sentinel <> { out( "Stack mismatch!" ) debugger } if
  "End of test " prefix out
  drop

to debug-test  ~~ Helper for tests that needs to be debugged
  "Testing " prefix out
  dup
  "test-" swap text.join, debug, run-name, normal-debug
  ~~ ToDo: developer must also check that data stack is unchanged
  "End of debug-test for " prefix out
  drop


to InoxStyle
  ~~ ToDo: some literate-inox dialect
  inox-dialect
  alias(  "To"           "to"               )
  alias(  "While"        " while: { "       )
  alias(  "Do"           " } do: { "        )
  alias(  "EndWhile"     " } ; "            )
  alias(  "Loop"         " loop: { "        )
  alias(  "Until"        " } until: { "     )
  alias(  "EndLoop"      " } ; "            )
  alias(  "Break"        "break"            )
  alias(  "If"           " if: "            )
  alias(  "Then"         " then: { "        )
  alias(  "Else"         " } else: { "      )
  alias(  "EndIf"        " } ; "            )
  alias(  "Times"        "times: "          )
  alias(  "Begin"        "{"                )
  alias(  "End"          "}"                )
  alias(  "Scope"        "0 {"              )
  alias(  "EndScope"     " } do-with-it "   )
InoxStyle

To False  false.
To True   true.


global: /speed-index-loops is: 1;

to speed-index
  if: fast? then: {
    if: fast? then: {
      10000000 speed-index-loops!
    } else: {
      2 speed-index-loops!
    };
    ~~ How long for integer addition?
    now
      times: speed-index-loops do: { 1 1 + drop };
    now swap -
    ~~ How long for no operation?
    now
      times: speed-index-loops do: {  };
    now swap -
    ~~ Delta is how long for additions alone
    -
    speed-index-loops " times 1 1 + drop in " &
    swap " ms" &
    & out
  };
speed-index

~~ forth.nox comes next
