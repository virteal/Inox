#!/bin/inox
#  smoke.nox
#    if it terminates, not all hope is lost
#
# December 6 2022 by jhr, extracted from lib/inox.ts, adding oo stuff
# January 11 2022 by jhr, extract to lib/bootstrap.nox

inox-dialect


to make-point  x:0 y:0 point:3 make-object

to test-point
  make-point
  dump
  1 _point.x!  ~~ ToDo: _point x:1 .! or even x:1.!
  2 _point.y!
  out( "( x:" & _point.x & ", y:" & _point.y & " )" )
  drop  ~~ forget point object
point/test


to point.out  method: { out( "( x:" & it.x & ", y:" & it.y & " )" ) };.

to test-method-call
  make-point
  _point .:out   ~~ ToDo: _point.:out
  _point .out()  ~~ ToDo: _point.out()
  drop  ~~ forget point object
method-call/test


to test-it-operations
  0 it{
    out( "Initial it should be 0, is " & it )
    increment-it!
    out( "Incremented it should be 1, is " & ii )
    decrement-it!
    out( "Decremented it should be 0, is " & ii )
    10 it!
    out( "New value of it should be 10, is " & it )
    out( "++it! should be 11, is " & ++it! )
    out( "it++! should be 11, is " & it++! )
    out( "it--! should be 12, is " & it--! )
    out( "--it! should be 10, is " & --it! )
    out( "it should be 10, is "    & it    )
  }
it-operations/test


to test-false-while
  while: { false } do: { out( "!!! never reached" ) };
false-while/test


to test-times-do
  times: 3 do: { out( "Time´goes on" ) } ;
times-do/test


to swap/  with /a /b  fn{ a> >A, b> >B, B> A> }.

to test-swap/
  2 3 swap/()
  "2 3 swap/(), top should be 2, is "  prefix out
  if: <>? 2 then: { out( "Expected 2 but got " prefix ) debugger };
  "2 3 swap/(), next should be 3, is " prefix out drop
  swap/( 4, 5 )
  "swap/( 4, 5 ), top should be 4, is "  prefix out drop
  "swap/( 4, 5 ), next should be 5, is " prefix out drop
"swap/" test


to test-break
  while: { true } do: { break }. ~~ ToDo: issue with dot, use token-debugger }.
break/test


to test-forever-while
  while: { true } do: {
    out( "forever" )
    while: { true } do: {
      out( "deeper" )
      while: { true } do: {
        out( "to the limit" )
        break
        out( "!!! never reached, to the limit" )
      };
      break
      out( "!!! never reach, deeper" )
    };
    break
    out( "!!! never reached, forever" )
  };
  out( "test forever ok" )
forever-while/test


to test-loop-break
  1 it{
    loop: {
      out( "loop-while body" )
      out( "Hello loop " & it )
      decrement-it!
      if: it <0? then: { break };
    };
  }
loop-break/test


to say:to:  swap out out( " " ) out.

to hello out( "hello world!" ).


forth-dialect ( forth )
: HELLO CR ." HELLO forth world!" ;
inox-dialect  ~~ back to inox


to test-HELLO
  say: "Hello" to: "Smalltalk world!";
  "HELLO" run-name
  "HELLO" definition run
  { HELLO } run
  true { hello } if
  if: true then: {
    HELLO
  } else: {
    hello
  };
HELLO/test


to test-loop1
  0 it{
    3 it!
    while: { decrement-it!, it >0? } do: {
      if:    it % 2 =0?
      then:  { out( it & " is even" ) }
      else:  { out( it & " is odd"  ) } ;
    };
    out( "test loop1 ok 1" )
    times: 3 do: {
      out( "bravo" )
    } ;
    out( "test loop1 ok 2" )
    loop: {
      out( "great" )
      break
    } ;
    out( "test loop1 ok 3, all ok" )
  }
loop1/test


To test-Loop2
  Scope
    3 it!
    While --it! >0? Do
      If it % 2 =0? Then
        out( it & " is even" )
      Else
        out( it & " is odd" )
      EndIf
    EndWhile
    Times 3 Loop
      out( "bravo" )
    EndLoop
    Loop
      out( "great" )
      Break
    EndLoop
    Loop
      out( "wonder" )
      Break
    EndLoop
  EndScope

Loop2/test

set-literate: true;

In order
  To test-literate
programming experimental mode, I just need to make sure that this test-literal verb does no more than
  Out( "test-literate ok" ).

So let's try with literate/test that should invoke the test verb with the tag literate as parameter
  Literate/Test

Please note that literate code is ok with lowercase verbs only, it does not work with camelcase verbs nor with punctation, except for the , that is non significant in all cases and there for cosmetic reasons only

It does work with forth uppercase verbs because the rule about uppercase does not apply when the second character is also an uppercase character

  ToDo: "Ignore dots and maybe other punctuations when in literate style?";

and then I need to restore the non literate mode using
  Set-literate( False )


out( "End of Iɴᴏx smoke test" )
