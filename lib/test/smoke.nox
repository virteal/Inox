#!/bin/inox
# December 6 2022 by jhr, extracted from lib/inox.ts, adding oo stuff

inox-dialect
~~ Inox is multi dialects, Inox dialect is the main one, Forth is another one.

to word-missing "word-missing " over inox-join-text inox-out inox-debugger.
~~ It is dynamically possible to implement the behavior of undefined words.
~~ word-missing is what Ruby use for method-missing, see below.

to method-missing "method-missing " over inox-join-text inox-debugger drop.
~~ The same is true for methods, ie words for objects.
~~ This is like doesNotUnderstand in Smalltalk.
~~ See http://rmod-pharo-mooc.lille.inria.fr/OOPMooc/07-DeeperIntoLookup/W7S01-InheritanceAndLookup-4-DoesNotUnderstand.pdf


to log inox-log.  ~~ This is console.log or maybe stderr (ToDo)

~~ clear both the data and the control stacks.
to clear-stacks inox-data-clear inox-control-clear.

~~ Casting is unsafe
to cast inox-cast.
to as-void    cast( void    ).
to as-integer cast( integer ).

to constant:is: inox-constant-create.
to global:is:   inox-global-create.
~~ There are global constants and global dynamic variables

to init-constants
~~ Setup some globals
  constant: inox-version is: "v0.2";
  constant: void         is: as-void( void:0 );
  constant: true         is: true:1;
  constant: false        is: false:0;
init-constants

~~ Some basic vocabulary
to debugger      inox-debugger.
to out           inox-out.
to without       inox-without.
to with-it       inox-with-it.
to without-it    inox-without-it.
to it            inox-it.
to call          inox-call.
to if            inox-if.
to if-call       inox-if-call.
to break         inox-break.
to inline        inox-inline.
to while         inox-while-1 inox-while-2 inox-while-3. inline
to until         inox-while-1 inox-while-2 inox-until-3. inline
to sentinel      inox-sentinel.
to jump          inox-jump.
to loop          inox-loop.
to make-object   inox-make-object.
to call:         inox-call.
to if-else       inox-if-else.

~~ Some more, using keyword syntax for ease
to call:         call.          inline
to if:then:      if call.       inline
to if:then:else: if-else call.  inline
to if:do:        if:then:.      inline
to while:do:     while.         inline
to until:do:     until.         inline
to loop:         loop.          inline
~~to loop-while  inox-loop-while.    inline
~~to loop-until  inox-loop-until.    inline
~~to loop:while: loop-while.         inline
~~to loop:until: loop-until.         inline

~~ ToDo: class hierarchy:
~~ - thing
~~  - value
~~    - void
~~    - tag
~~    - number
~~    - integer
~~    - float
~~    - text
~~  - object
~~    - native
~~    - block
~~    - word
~~    - proxy
~~    - interable
~~      - array
~~      - map
~~    - flow

to thing.class /thing.
to thing.super-class /void.

to value.class /value.
to value.super-class /thing.

to void.class /void.
to void.super-class /value.

to tag.class /tag.
to tag.super-class /value.

to number.class /number.
to number.super-class /value.

to integer.class /integer.
to integer.super-class /value.

to float.class /float.
to float.super-class /value.

to object.class /object.
to object.super-class /thing.

to native.class /native.
to native.super-class /object.

to block.class /block.
to block.super-class /object.

to word.class  /block.
to word.super-class /object.


to object.then: if call.
to object.else: not if call.
to block.while: while. inline.
to block.until: until. inline.


to ToDo: out( "ToDo: " & swap ).

to dump  ~~ something --
~~ Debug dump of top of stack. TOS is not preserved.
  ~~ ToDo |tos| to avoid tos| |tos sequences
  dup
  dup                        ~~ someting something
  inox-get-class             ~~ something _class
  swap                       ~~ _class something
  dup                        ~~ _class something something
  inox-get-type              ~~ _class something _type
  swap                       ~~ _class _type something
  dup                        ~~ _class _type something something
  inox-get-name              ~~ _class _type something _name
  swap                       ~~ _class _type _name something
  dup                        ~~ _class _type _name something something
  inox-get-value             ~~ _class _type _name something _value
  swap                       ~~ _class _type _name _value something
  out(
      "class: "  & _class
    & " type: "  & _type
    & " name: "  & _name
    & " value: " & _value
  )
  drop drop drop drop  drop ~~ ToDo: nn drops or some trick like xxxx nn times

to dump-object  ~~ any -- any
  dump
  ToDo: "dump each member";

to method:  ~~ a-block --
~~ Execute a block with an "it" local variable that points to the target
~~ object. Use { b| a| ... } to get more local variables. Use (| a| b| |)
~~ to reverse the order of these parameters like most languages do, some
~~ small overhead is involved however.
~~ ToDo: function-method:
  ~~ Store target into the it control variable
  swap with-it
    ~~ ToDo: optimize with some inox-method-call primitive
    call
  ~~ Clear the control stack down to the it variable included
  without-it


to debug
~~ During developpment I often need a lot of traces
  dont/log ~~ Do not log this
  token/enable/log
  parse/enable/log
  eval/enable/log
  run/enable/log
  stack/enable/log
  do/log ~~ now log!


to no-debug
~~ Back to normal
  step/disable/log
  token/disable/log
  dont/log


~~ Some basic text manipulations
to join-text inox-join-text.            ~~ A B -- AB
to prefix    over join-text.            ~~ A B -- A BA
to suffix    over swap inox-join-text.  ~~ A B -- A AB


to test ~~ name --
~~ Helper to test words. It runs the test-xxx testing word.
  ~~ add a sentinel to detect stack mismatch, it should be the TOS at the end.
  dup                  ~~ name name
  /test-sentinel swap  ~~ name /test-sentinel name
  inox-tag             ~~ name /test-sentinel tag
  inox-rename swap     ~~ tag:/test-sentinel name
  ~~ run test
  "Testing "         prefix inox-out
  "test-"            prefix inox-call-by-name
  "End of test for " prefix inox-out
  drop
  ~~ checks that stack is unchanged, ie sentinel is still at the top
  /test-sentinel <>? { inox-out( "Stack mismatch!" ) debugger } inox-if-call


to debug-test
~~ Helper for tests that needs to be debugged
  "Testing " prefix out
  "test-"    prefix debug inox-call-by-name no-debug
  ~~ ToDo: developer must check that data stack is unchanged
  "End of debug-test for " prefix out
  drop

to make-point x:0 y:0 point:2 inox-make-object.

to test-point
  make-point
  dump
  1 _point.x! ~~ ToDo: _point x:1.!
  2 _point.y!
  out( "( x:" & _point.x & ", y:" & _point.y & " )" )
  drop ~~ forget point object
point/test


to point.out method: { out( "( x:" & it.x & ", y:" & it.y & " )" ) };.

to test-method-call
  make-point
  _point .:out
  _point .out()
  drop ~~ forget point object
method-call/test


to decrement ( 1 - ).
to increment ( 1 + ).

to with-ii 0 ii|. inline
to without-ii /ii inox-without. inline
to with-ii-do: with-ii call without-ii.
to ii! |ii!. inline
to ii  |ii. inline
to decrement-ii ii decrement ii!.
to increment-ii ii increment ii!.
to --ii ii decrement dup ii!. ~~ |ii 1 - dup |ii!
to ++ii ii increment dup ii!.
to ii-- ii decrement-ii.
to ii++ ii increment-ii.

to test-ii-operations
  with-ii
    out( "Initial ii should be 0, is " & ii )
    increment-ii
    out( "Incremented ii should be 1, is " & ii )
    decrement-ii
    out( "Decremented ii should be 0, is " & ii )
    10 ii!
    out( "New value of ii should be 10, is " & ii )
    out( "++ii should be 11, is " & ++ii )
    out( "ii++ should be 11, is " & ii++ )
    out( "ii-- should be 12, is " & ii-- )
    out( "--ii should be 10, is " & --ii )
    out( "ii should be 10, is "   & ii   )
  without-ii
ii-operations/test


to test-false-while
  while: { 0 } do: { out( "!!! never reached" ) };
false-while/test


to test-break
  while: { true } do: { break }. ~~ ToDo: issue with dot, use token-debugger }.
break/test


to test-forever-while
  while: { true } do: {
    out( "forever" )
    while: { true } do: {
      out( "deeper" )
      while: { true } do: {
        out( "to the limit" )
        break
        out( "!!! never reached, to the limit" )
      };
      break
      out( "!!! never reach, deeper" )
    };
    break
    out( "!!! never reached, forever" )
  };
  out( "test forever ok" )
forever-while/test


to test-loop-break
  with-ii
  2 ii!
  loop: {
    out( "loop-while body" )
    out( "Hello loop " & ii )
    decrement-ii
    if: ii <0? then: { break };
  };
  without-ii
loop-break/test


to times:do:
  times:do/sentinel
  blk| nn| ~~ begin
  if: |nn >0? then: {
    while: {
      ( |nn - 1 ) dup |nn! >=0?
    } do: {
      |blk call
    };
  };
  times:do/jump

to times:loop: times:do:.

to test-times-do
  times: 3 do: { out( "TimeÂ´goes on" ) } ;
times-do/test


~~ words with formal parameters are functions called with arguments

to with /inox-with.
to (| inox-with-control.
to |) inox-without-with-control. inox-inline

~~ ToDo: closures, partial, complete, shared
~~ to closure inox-copy-closure.
~~ to stack-closure inox-copy-stack-closure.

~~ ToDo: array builder using a sentinel in the data stack
~~ to [# with.
~~ to #] inox-create-with-array.

~~ Test call to function. By convention a word that is a function
~~ ends with a / meaning "word is applied on parameters, it's a function"

~~ Functions run with arguments and can have local variables, dynamic ones.
to swap/ with /a /b (| |a x|, |b y|, |y |x |).

~~ ToDo: to swap/ with /a /b function: { xxxx }.

to test-swap/
  2 3 swap/
  "2 3 swap/, top should be 2, is "  prefix out
  if: <>? 2 then: { out( "Expected 2 but got " prefix ) debugger };
  "2 3 swap/, next should be 3, is " prefix out drop
  swap/( 4, 5 )
  "swap/( 4, 5 ), top should be 4, is "  prefix out drop
  "swap/( 4, 5 ), next should be 5, is " prefix out drop

out( "About to /swap /debug-test")
"swap/" test

to say:to: swap out out( " " ) out.

say: "Hello" to: "Smalltalk world!".

to hello out( "Hello world!" ).

hello()

forth-dialect ( forth )

: HELLO CR ." Hello forth world!" ;
HELLO

inox-dialect ~~ inox

to test-HELLO
  "HELLO" inox-call-by-name
  "HELLO" inox-definition call
  { HELLO } call
  1 { hello } if call
  if: 1 then: {
    HELLO
  } else: {
    hello
  };
HELLO/test

to test-loop1
  with-ii
    3 ii!
    while: { decrement-ii, ii >0? } do: {
      if:    ii % 2 =0?
      then:  { out( ii & " is even" ) }
      else:  { out( ii & " is odd"  ) } ;
    } ;
    out( "test loop1 ok 1" )
    times: 3 do: {
      out( "bravo" )
    } ;
    out( "test loop1 ok 2" )
    loop: {
      out( "great" )
      break
    } ;
    out( "test loop1 ok 3, all ok" )
  without-ii
loop1/test


to InoxStyle
  inox-dialect
  inox-alias( "To",          " to "            )
  inox-alias( "EndTo",       " . "             )
  inox-alias( "While",       " while: { "      )
  inox-alias( "Do",          " } do: { "       )
  inox-alias( "EndWhile",    " } ; "           )
  inox-alias( "Loop",        " loop: { "       )
  inox-alias( "Until",       " } until: { "    )
  inox-alias( "EndLoop",     " } ; "           )
  inox-alias( "Break",       " break "         )
  inox-alias( "If",          " if: "           )
  inox-alias( "Then",        " then: { "       )
  inox-alias( "Else",        " } else: { "     )
  inox-alias( "EndIf",       " } ; "           )
  inox-alias( "Times",       " times: "        )
  inox-alias( "Begin",       " { "             )
  inox-alias( "End",         " } ; "           )
InoxStyle

debug

To test-Loop2
  with-ii-do: Begin
    3 ii!
    While --ii >0? Do
      If ii % 2 =0? Then
        out( ii & " is even" )
      Else
        out( ii & " is odd" )
      EndIf
    EndWhile
    Times 3 Loop
      out( "bravo" )
    EndLoop
    Loop
      out( "great" )
      Break
    EndLoop
    Loop
      out( "wonder" )
      Break
    EndLoop
  End
EndTo

Loop2/test


to try:
  try/sentinel
    call
  try/jump

to try:catch:
  try:catch/sentinel
    catch|
    if: inox-mark then: {
      call
    } else: {
      |catch call
    };
  try:catch/jump

to try:catch:finally:
  try:catch:finally/sentinel
    finally|
    try:catch:;
    |finally call
  try:catch:finally/jump

out( "End of smoke test" )
